
<!DOCTYPE html>
<html lang="en"><head>
    <meta charset="UTF-8">
</head><body>

    <div class="document" itemscope="itemscope" itemtype="http://schema.org/Article" role="main">
<center><h3>ItemLoaders</h3></center>
<div itemprop="articleBody">
<div class="section" id="module-scrapy.contrib.loader">
<span id="item-loaders"></span><span id="topics-loaders"></span><h1>Item Loaders<a class="headerlink" href="#module-scrapy.contrib.loader" title="永久链接至标题"></a></h1>
<p>Item Loaders 提供了一种简便的构件（mechanism）来抓取:ref:<cite>Items&lt;topics-items&gt;</cite>.
虽然Items可以从它自己的类似字典（dictionary-like）的API得到所需信息 ,不过
Item Loaders提供了许多更加方便的API，这些API通过自动完成那些具有共通性的任务，可从抓取进程中得到这些信息,
比如预先解析提取到的原生数据。
换句话来解释, <a class="reference internal" href="items.html#topics-items"><span class="std std-ref">Items</span></a> 提供了盛装抓取到的数据的*容器*
, 而Item Loaders提供了构件*装载populating*该容器。</p>
<p>Item Loaders 被设计用来提供一个既弹性又高效简便的构件，
以扩展或重写爬虫或源格式(HTML, XML之类的)等区域的解析规则，
这将不再是后期维护的噩梦。</p>
<div class="section" id="item-loadersitems">
<h2>用Item Loaders装载Items<a class="headerlink" href="#item-loadersitems" title="永久链接至标题"></a></h2>
<p>要使用Item Loader, 你必须先将它实例化. 你可以使用类似字典的对象(例如: Item or dict)来进行实例化, 或者不使用对象也可以, 当不用对象进行实例化的时候,Item会自动使用 <a class="reference internal" href="#scrapy.contrib.loader.ItemLoader.default_item_class" title="scrapy.contrib.loader.ItemLoader.default_item_class"><code class="xref py py-attr docutils literal"><span class="pre">ItemLoader.default_item_class</span></code></a>
属性中指定的Item 类在Item Loader constructor中实例化.</p>
<p>然后,你开始收集数值到Item Loader时,通常使用
<a class="reference internal" href="selectors.html#topics-selectors"><span class="std std-ref">Selectors</span></a>. 你可以在同一个item field 里面添加多个数值;Item Loader将知道如何用合适的处理函数来“添加”这些数值.</p>
<p>下面是在 <a class="reference internal" href="spiders.html#topics-spiders"><span class="std std-ref">Spider</span></a> 中典型的Item Loader的用法, 使用 <a class="reference internal" href="items.html#topics-items"><span class="std std-ref">Items chapter</span></a> 中声明的 <a class="reference internal" href="items.html#topics-items-declaring"><span class="std std-ref">Product item</span></a>:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">scrapy.contrib.loader</span> <span class="k">import</span> <span class="n">ItemLoader</span>
<span class="kn">from</span> <span class="nn">myproject.items</span> <span class="k">import</span> <span class="n">Product</span>

<span class="k">def</span> <span class="nf">parse</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">response</span><span class="p">):</span>
    <span class="n">l</span> <span class="o">=</span> <span class="n">ItemLoader</span><span class="p">(</span><span class="n">item</span><span class="o">=</span><span class="n">Product</span><span class="p">(),</span> <span class="n">response</span><span class="o">=</span><span class="n">response</span><span class="p">)</span>
    <span class="n">l</span><span class="o">.</span><span class="n">add_xpath</span><span class="p">(</span><span class="s1">'name'</span><span class="p">,</span> <span class="s1">'//div[@class="product_name"]'</span><span class="p">)</span>
    <span class="n">l</span><span class="o">.</span><span class="n">add_xpath</span><span class="p">(</span><span class="s1">'name'</span><span class="p">,</span> <span class="s1">'//div[@class="product_title"]'</span><span class="p">)</span>
    <span class="n">l</span><span class="o">.</span><span class="n">add_xpath</span><span class="p">(</span><span class="s1">'price'</span><span class="p">,</span> <span class="s1">'//p[@id="price"]'</span><span class="p">)</span>
    <span class="n">l</span><span class="o">.</span><span class="n">add_css</span><span class="p">(</span><span class="s1">'stock'</span><span class="p">,</span> <span class="s1">'p#stock]'</span><span class="p">)</span>
    <span class="n">l</span><span class="o">.</span><span class="n">add_value</span><span class="p">(</span><span class="s1">'last_updated'</span><span class="p">,</span> <span class="s1">'today'</span><span class="p">)</span> <span class="c1"># you can also use literal values</span>
    <span class="k">return</span> <span class="n">l</span><span class="o">.</span><span class="n">load_item</span><span class="p">()</span>
</pre></div>
</div>
<p>快速查看这些代码之后,我们可以看到发现 <code class="docutils literal"><span class="pre">name</span></code>  字段被从页面中两个不同的XPath位置提取:</p>
<ol class="arabic simple">
<li><code class="docutils literal"><span class="pre">//div[@class="product_name"]</span></code></li>
<li><code class="docutils literal"><span class="pre">//div[@class="product_title"]</span></code></li>
</ol>
<p>换言之,数据通过用 <a class="reference internal" href="#scrapy.contrib.loader.ItemLoader.add_xpath" title="scrapy.contrib.loader.ItemLoader.add_xpath"><code class="xref py py-meth docutils literal"><span class="pre">add_xpath()</span></code></a> 的方法,把从两个不同的XPath位置提取的数据收集起来. 这是将在以后分配给 <code class="docutils literal"><span class="pre">name</span></code> 字段中的数据｡</p>
<p>之后,类似的请求被用于 <code class="docutils literal"><span class="pre">price</span></code> 和 <code class="docutils literal"><span class="pre">stock</span></code> 字段
(后者使用 CSS selector 和 <a class="reference internal" href="#scrapy.contrib.loader.ItemLoader.add_css" title="scrapy.contrib.loader.ItemLoader.add_css"><code class="xref py py-meth docutils literal"><span class="pre">add_css()</span></code></a> 方法),
最后使用不同的方法 <a class="reference internal" href="#scrapy.contrib.loader.ItemLoader.add_value" title="scrapy.contrib.loader.ItemLoader.add_value"><code class="xref py py-meth docutils literal"><span class="pre">add_value()</span></code></a> 对 <code class="docutils literal"><span class="pre">last_update</span></code> 填充文本值( <code class="docutils literal"><span class="pre">today</span></code> ).</p>
<p>最终, 当所有数据被收集起来之后, 调用 <a class="reference internal" href="#scrapy.contrib.loader.ItemLoader.load_item" title="scrapy.contrib.loader.ItemLoader.load_item"><code class="xref py py-meth docutils literal"><span class="pre">ItemLoader.load_item()</span></code></a> 方法, 实际上填充并且返回了之前通过调用 <a class="reference internal" href="#scrapy.contrib.loader.ItemLoader.add_xpath" title="scrapy.contrib.loader.ItemLoader.add_xpath"><code class="xref py py-meth docutils literal"><span class="pre">add_xpath()</span></code></a>,
<a class="reference internal" href="#scrapy.contrib.loader.ItemLoader.add_css" title="scrapy.contrib.loader.ItemLoader.add_css"><code class="xref py py-meth docutils literal"><span class="pre">add_css()</span></code></a>, and <a class="reference internal" href="#scrapy.contrib.loader.ItemLoader.add_value" title="scrapy.contrib.loader.ItemLoader.add_value"><code class="xref py py-meth docutils literal"><span class="pre">add_value()</span></code></a> 所提取和收集到的数据的Item.</p>
</div>
<div class="section" id="input-and-output-processors">
<span id="topics-loaders-processors"></span><h2>Input and Output processors<a class="headerlink" href="#input-and-output-processors" title="永久链接至标题"></a></h2>
<p>Item Loader在每个(Item)字段中都包含了一个输入处理器和一个输出处理器｡ 输入处理器收到数据时立刻提取数据 (通过 <a class="reference internal" href="#scrapy.contrib.loader.ItemLoader.add_xpath" title="scrapy.contrib.loader.ItemLoader.add_xpath"><code class="xref py py-meth docutils literal"><span class="pre">add_xpath()</span></code></a>, <a class="reference internal" href="#scrapy.contrib.loader.ItemLoader.add_css" title="scrapy.contrib.loader.ItemLoader.add_css"><code class="xref py py-meth docutils literal"><span class="pre">add_css()</span></code></a> 或者
<a class="reference internal" href="#scrapy.contrib.loader.ItemLoader.add_value" title="scrapy.contrib.loader.ItemLoader.add_value"><code class="xref py py-meth docutils literal"><span class="pre">add_value()</span></code></a> 方法) 之后输入处理器的结果被收集起来并且保存在ItemLoader内. 收集到所有的数据后, 调用
<a class="reference internal" href="#scrapy.contrib.loader.ItemLoader.load_item" title="scrapy.contrib.loader.ItemLoader.load_item"><code class="xref py py-meth docutils literal"><span class="pre">ItemLoader.load_item()</span></code></a> 方法来填充,并得到填充后的
<a class="reference internal" href="items.html#scrapy.item.Item" title="scrapy.item.Item"><code class="xref py py-class docutils literal"><span class="pre">Item</span></code></a> 对象.  这是当输出处理器被和之前收集到的数据(和用输入处理器处理的)被调用.输出处理器的结果是被分配到Item的最终值｡</p>
<p>让我们看一个例子来说明如何输入和输出处理器被一个特定的字段调用(同样适用于其他field)::</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">l</span> <span class="o">=</span> <span class="n">ItemLoader</span><span class="p">(</span><span class="n">Product</span><span class="p">(),</span> <span class="n">some_selector</span><span class="p">)</span>
<span class="n">l</span><span class="o">.</span><span class="n">add_xpath</span><span class="p">(</span><span class="s1">'name'</span><span class="p">,</span> <span class="n">xpath1</span><span class="p">)</span> <span class="c1"># (1)</span>
<span class="n">l</span><span class="o">.</span><span class="n">add_xpath</span><span class="p">(</span><span class="s1">'name'</span><span class="p">,</span> <span class="n">xpath2</span><span class="p">)</span> <span class="c1"># (2)</span>
<span class="n">l</span><span class="o">.</span><span class="n">add_css</span><span class="p">(</span><span class="s1">'name'</span><span class="p">,</span> <span class="n">css</span><span class="p">)</span> <span class="c1"># (3)</span>
<span class="n">l</span><span class="o">.</span><span class="n">add_value</span><span class="p">(</span><span class="s1">'name'</span><span class="p">,</span> <span class="s1">'test'</span><span class="p">)</span> <span class="c1"># (4)</span>
<span class="k">return</span> <span class="n">l</span><span class="o">.</span><span class="n">load_item</span><span class="p">()</span> <span class="c1"># (5)</span>
</pre></div>
</div>
<p>发生了这些事情:</p>
<ol class="arabic simple">
<li>从 <code class="docutils literal"><span class="pre">xpath1</span></code> 提取出的数据,传递给 <em>输入处理器</em> 的 <code class="docutils literal"><span class="pre">name</span></code> 字段.输入处理器的结果被收集和保存在Item Loader中(但尚未分配给该Item)｡</li>
<li>从 <code class="docutils literal"><span class="pre">xpath2</span></code> 提取出来的数据,传递给(1)中使用的相同的 <em>输入处理器</em> .输入处理器的结果被附加到在(1)中收集的数据(如果有的话) ｡</li>
<li>This case is similar to the previous ones, except that the data is extracted
from the <code class="docutils literal"><span class="pre">css</span></code> CSS selector, and passed through the same <em>input
processor</em> used in (1) and (2). The result of the input processor is appended to the
data collected in (1) and (2) (if any).</li>
<li>This case is also similar to the previous ones, except that the value to be
collected is assigned directly, instead of being extracted from a XPath
expression or a CSS selector.
However, the value is still passed through the input processors. In this
case, since the value is not iterable it is converted to an iterable of a
single element before passing it to the input processor, because input
processor always receive iterables.</li>
<li>The data collected in steps (1), (2), (3) and (4) is passed through
the <em>output processor</em> of the <code class="docutils literal"><span class="pre">name</span></code> field.
The result of the output processor is the value assigned to the <code class="docutils literal"><span class="pre">name</span></code>
field in the item.</li>
</ol>
<p>It’s worth noticing that processors are just callable objects, which are called
with the data to be parsed, and return a parsed value. So you can use any
function as input or output processor. The only requirement is that they must
accept one (and only one) positional argument, which will be an iterator.</p>
<div class="admonition note">
<p class="first admonition-title">注解</p>
<p class="last">Both input and output processors must receive an iterator as their
first argument. The output of those functions can be anything. The result of
input processors will be appended to an internal list (in the Loader)
containing the collected values (for that field). The result of the output
processors is the value that will be finally assigned to the item.</p>
</div>
<p>The other thing you need to keep in mind is that the values returned by input
processors are collected internally (in lists) and then passed to output
processors to populate the fields.</p>
<p>Last, but not least, Scrapy comes with some <a class="reference internal" href="#topics-loaders-available-processors"><span class="std std-ref">commonly used processors</span></a> built-in for convenience.</p>
</div>
<div class="section" id="declaring-item-loaders">
<h2>Declaring Item Loaders<a class="headerlink" href="#declaring-item-loaders" title="永久链接至标题"></a></h2>
<p>Item Loaders are declared like Items, by using a class definition syntax. Here
is an example:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">scrapy.contrib.loader</span> <span class="k">import</span> <span class="n">ItemLoader</span>
<span class="kn">from</span> <span class="nn">scrapy.contrib.loader.processor</span> <span class="k">import</span> <span class="n">TakeFirst</span><span class="p">,</span> <span class="n">MapCompose</span><span class="p">,</span> <span class="n">Join</span>

<span class="k">class</span> <span class="nc">ProductLoader</span><span class="p">(</span><span class="n">ItemLoader</span><span class="p">):</span>

    <span class="n">default_output_processor</span> <span class="o">=</span> <span class="n">TakeFirst</span><span class="p">()</span>

    <span class="n">name_in</span> <span class="o">=</span> <span class="n">MapCompose</span><span class="p">(</span><span class="n">unicode</span><span class="o">.</span><span class="n">title</span><span class="p">)</span>
    <span class="n">name_out</span> <span class="o">=</span> <span class="n">Join</span><span class="p">()</span>

    <span class="n">price_in</span> <span class="o">=</span> <span class="n">MapCompose</span><span class="p">(</span><span class="n">unicode</span><span class="o">.</span><span class="n">strip</span><span class="p">)</span>

    <span class="c1"># ...</span>
</pre></div>
</div>
<p>As you can see, input processors are declared using the <code class="docutils literal"><span class="pre">_in</span></code> suffix while
output processors are declared using the <code class="docutils literal"><span class="pre">_out</span></code> suffix. And you can also
declare a default input/output processors using the
<a class="reference internal" href="#scrapy.contrib.loader.ItemLoader.default_input_processor" title="scrapy.contrib.loader.ItemLoader.default_input_processor"><code class="xref py py-attr docutils literal"><span class="pre">ItemLoader.default_input_processor</span></code></a> and
<a class="reference internal" href="#scrapy.contrib.loader.ItemLoader.default_output_processor" title="scrapy.contrib.loader.ItemLoader.default_output_processor"><code class="xref py py-attr docutils literal"><span class="pre">ItemLoader.default_output_processor</span></code></a> attributes.</p>
</div>
<div class="section" id="declaring-input-and-output-processors">
<span id="topics-loaders-processors-declaring"></span><h2>Declaring Input and Output Processors<a class="headerlink" href="#declaring-input-and-output-processors" title="永久链接至标题"></a></h2>
<p>As seen in the previous section, input and output processors can be declared in
the Item Loader definition, and it’s very common to declare input processors
this way. However, there is one more place where you can specify the input and
output processors to use: in the <a class="reference internal" href="items.html#topics-items-fields"><span class="std std-ref">Item Field</span></a>
metadata. Here is an example:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">scrapy</span>

<span class="kn">from</span> <span class="nn">scrapy.contrib.loader.processor</span> <span class="k">import</span> <span class="n">Join</span><span class="p">,</span> <span class="n">MapCompose</span><span class="p">,</span> <span class="n">TakeFirst</span>
<span class="kn">from</span> <span class="nn">w3lib.html</span> <span class="k">import</span> <span class="n">remove_tags</span>

<span class="k">def</span> <span class="nf">filter_price</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">value</span><span class="o">.</span><span class="n">isdigit</span><span class="p">():</span>
        <span class="k">return</span> <span class="n">value</span>

<span class="k">class</span> <span class="nc">Product</span><span class="p">(</span><span class="n">scrapy</span><span class="o">.</span><span class="n">Item</span><span class="p">):</span>
    <span class="n">name</span> <span class="o">=</span> <span class="n">scrapy</span><span class="o">.</span><span class="n">Field</span><span class="p">(</span>
        <span class="n">input_processor</span><span class="o">=</span><span class="n">MapCompose</span><span class="p">(</span><span class="n">remove_tags</span><span class="p">),</span>
        <span class="n">output_processor</span><span class="o">=</span><span class="n">Join</span><span class="p">(),</span>
    <span class="p">)</span>
    <span class="n">price</span> <span class="o">=</span> <span class="n">scrapy</span><span class="o">.</span><span class="n">Field</span><span class="p">(</span>
        <span class="n">input_processor</span><span class="o">=</span><span class="n">MapCompose</span><span class="p">(</span><span class="n">remove_tags</span><span class="p">,</span> <span class="n">filter_price</span><span class="p">),</span>
        <span class="n">output_processor</span><span class="o">=</span><span class="n">TakeFirst</span><span class="p">(),</span>
    <span class="p">)</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">scrapy.contrib.loader</span> <span class="k">import</span> <span class="n">ItemLoader</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">il</span> <span class="o">=</span> <span class="n">ItemLoader</span><span class="p">(</span><span class="n">item</span><span class="o">=</span><span class="n">Product</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">il</span><span class="o">.</span><span class="n">add_value</span><span class="p">(</span><span class="s1">'name'</span><span class="p">,</span> <span class="p">[</span><span class="sa">u</span><span class="s1">'Welcome to my'</span><span class="p">,</span> <span class="sa">u</span><span class="s1">'&lt;strong&gt;website&lt;/strong&gt;'</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">il</span><span class="o">.</span><span class="n">add_value</span><span class="p">(</span><span class="s1">'price'</span><span class="p">,</span> <span class="p">[</span><span class="sa">u</span><span class="s1">'&amp;euro;'</span><span class="p">,</span> <span class="sa">u</span><span class="s1">'&lt;span&gt;1000&lt;/span&gt;'</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">il</span><span class="o">.</span><span class="n">load_item</span><span class="p">()</span>
<span class="go">{'name': u'Welcome to my website', 'price': u'1000'}</span>
</pre></div>
</div>
<p>The precedence order, for both input and output processors, is as follows:</p>
<ol class="arabic simple">
<li>Item Loader field-specific attributes: <code class="docutils literal"><span class="pre">field_in</span></code> and <code class="docutils literal"><span class="pre">field_out</span></code> (most
precedence)</li>
<li>Field metadata (<code class="docutils literal"><span class="pre">input_processor</span></code> and <code class="docutils literal"><span class="pre">output_processor</span></code> key)</li>
<li>Item Loader defaults: <a class="reference internal" href="#scrapy.contrib.loader.ItemLoader.default_input_processor" title="scrapy.contrib.loader.ItemLoader.default_input_processor"><code class="xref py py-meth docutils literal"><span class="pre">ItemLoader.default_input_processor()</span></code></a> and
<a class="reference internal" href="#scrapy.contrib.loader.ItemLoader.default_output_processor" title="scrapy.contrib.loader.ItemLoader.default_output_processor"><code class="xref py py-meth docutils literal"><span class="pre">ItemLoader.default_output_processor()</span></code></a> (least precedence)</li>
</ol>
<p>See also: <a class="reference internal" href="#topics-loaders-extending"><span class="std std-ref">Reusing and extending Item Loaders</span></a>.</p>
</div>
<div class="section" id="item-loader-context">
<span id="topics-loaders-context"></span><h2>Item Loader Context<a class="headerlink" href="#item-loader-context" title="永久链接至标题"></a></h2>
<p>The Item Loader Context is a dict of arbitrary key/values which is shared among
all input and output processors in the Item Loader. It can be passed when
declaring, instantiating or using Item Loader. They are used to modify the
behaviour of the input/output processors.</p>
<p>For example, suppose you have a function <code class="docutils literal"><span class="pre">parse_length</span></code> which receives a text
value and extracts a length from it:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">parse_length</span><span class="p">(</span><span class="n">text</span><span class="p">,</span> <span class="n">loader_context</span><span class="p">):</span>
    <span class="n">unit</span> <span class="o">=</span> <span class="n">loader_context</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">'unit'</span><span class="p">,</span> <span class="s1">'m'</span><span class="p">)</span>
    <span class="c1"># ... length parsing code goes here ...</span>
    <span class="k">return</span> <span class="n">parsed_length</span>
</pre></div>
</div>
<p>By accepting a <code class="docutils literal"><span class="pre">loader_context</span></code> argument the function is explicitly telling
the Item Loader that it’s able to receive an Item Loader context, so the Item
Loader passes the currently active context when calling it, and the processor
function (<code class="docutils literal"><span class="pre">parse_length</span></code> in this case) can thus use them.</p>
<p>There are several ways to modify Item Loader context values:</p>
<ol class="arabic">
<li><p class="first">By modifying the currently active Item Loader context
(<a class="reference internal" href="#scrapy.contrib.loader.ItemLoader.context" title="scrapy.contrib.loader.ItemLoader.context"><code class="xref py py-attr docutils literal"><span class="pre">context</span></code></a> attribute):</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">loader</span> <span class="o">=</span> <span class="n">ItemLoader</span><span class="p">(</span><span class="n">product</span><span class="p">)</span>
<span class="n">loader</span><span class="o">.</span><span class="n">context</span><span class="p">[</span><span class="s1">'unit'</span><span class="p">]</span> <span class="o">=</span> <span class="s1">'cm'</span>
</pre></div>
</div>
</li>
<li><p class="first">On Item Loader instantiation (the keyword arguments of Item Loader
constructor are stored in the Item Loader context):</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">loader</span> <span class="o">=</span> <span class="n">ItemLoader</span><span class="p">(</span><span class="n">product</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="s1">'cm'</span><span class="p">)</span>
</pre></div>
</div>
</li>
<li><p class="first">On Item Loader declaration, for those input/output processors that support
instantiating them with an Item Loader context. <a class="reference internal" href="#scrapy.contrib.loader.processor.MapCompose" title="scrapy.contrib.loader.processor.MapCompose"><code class="xref py py-class docutils literal"><span class="pre">MapCompose</span></code></a> is one of
them:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">ProductLoader</span><span class="p">(</span><span class="n">ItemLoader</span><span class="p">):</span>
    <span class="n">length_out</span> <span class="o">=</span> <span class="n">MapCompose</span><span class="p">(</span><span class="n">parse_length</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="s1">'cm'</span><span class="p">)</span>
</pre></div>
</div>
</li>
</ol>
</div>
<div class="section" id="itemloader-objects">
<h2>ItemLoader objects<a class="headerlink" href="#itemloader-objects" title="永久链接至标题"></a></h2>
<dl class="class">
<dt id="scrapy.contrib.loader.ItemLoader">
<em class="property">class </em><code class="descclassname">scrapy.contrib.loader.</code><code class="descname">ItemLoader</code><span class="sig-paren">(</span><span class="optional">[</span><em>item</em>, <em>selector</em>, <em>response</em>, <span class="optional">]</span><em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#scrapy.contrib.loader.ItemLoader" title="永久链接至目标"></a></dt>
<dd><p>Return a new Item Loader for populating the given Item. If no item is
given, one is instantiated automatically using the class in
<a class="reference internal" href="#scrapy.contrib.loader.ItemLoader.default_item_class" title="scrapy.contrib.loader.ItemLoader.default_item_class"><code class="xref py py-attr docutils literal"><span class="pre">default_item_class</span></code></a>.</p>
<p>When instantiated with a <cite>selector</cite> or a <cite>response</cite> parameters
the <a class="reference internal" href="#scrapy.contrib.loader.ItemLoader" title="scrapy.contrib.loader.ItemLoader"><code class="xref py py-class docutils literal"><span class="pre">ItemLoader</span></code></a> class provides convenient mechanisms for extracting
data from web pages using <a class="reference internal" href="selectors.html#topics-selectors"><span class="std std-ref">selectors</span></a>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"></col>
<col class="field-body"></col>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">参数:</th><td class="field-body"><ul class="first last simple">
<li><strong>item</strong> (<a class="reference internal" href="items.html#scrapy.item.Item" title="scrapy.item.Item"><code class="xref py py-class docutils literal"><span class="pre">Item</span></code></a> object) – The item instance to populate using subsequent calls to
<a class="reference internal" href="#scrapy.contrib.loader.ItemLoader.add_xpath" title="scrapy.contrib.loader.ItemLoader.add_xpath"><code class="xref py py-meth docutils literal"><span class="pre">add_xpath()</span></code></a>, <a class="reference internal" href="#scrapy.contrib.loader.ItemLoader.add_css" title="scrapy.contrib.loader.ItemLoader.add_css"><code class="xref py py-meth docutils literal"><span class="pre">add_css()</span></code></a>,
or <a class="reference internal" href="#scrapy.contrib.loader.ItemLoader.add_value" title="scrapy.contrib.loader.ItemLoader.add_value"><code class="xref py py-meth docutils literal"><span class="pre">add_value()</span></code></a>.</li>
<li><strong>selector</strong> (<a class="reference internal" href="selectors.html#scrapy.selector.Selector" title="scrapy.selector.Selector"><code class="xref py py-class docutils literal"><span class="pre">Selector</span></code></a> object) – The selector to extract data from, when using the
<a class="reference internal" href="#scrapy.contrib.loader.ItemLoader.add_xpath" title="scrapy.contrib.loader.ItemLoader.add_xpath"><code class="xref py py-meth docutils literal"><span class="pre">add_xpath()</span></code></a> (resp. <a class="reference internal" href="#scrapy.contrib.loader.ItemLoader.add_css" title="scrapy.contrib.loader.ItemLoader.add_css"><code class="xref py py-meth docutils literal"><span class="pre">add_css()</span></code></a>) or <a class="reference internal" href="#scrapy.contrib.loader.ItemLoader.replace_xpath" title="scrapy.contrib.loader.ItemLoader.replace_xpath"><code class="xref py py-meth docutils literal"><span class="pre">replace_xpath()</span></code></a>
(resp. <a class="reference internal" href="#scrapy.contrib.loader.ItemLoader.replace_css" title="scrapy.contrib.loader.ItemLoader.replace_css"><code class="xref py py-meth docutils literal"><span class="pre">replace_css()</span></code></a>) method.</li>
<li><strong>response</strong> (<a class="reference internal" href="request-response.html#scrapy.http.Response" title="scrapy.http.Response"><code class="xref py py-class docutils literal"><span class="pre">Response</span></code></a> object) – The response used to construct the selector using the
<a class="reference internal" href="#scrapy.contrib.loader.ItemLoader.default_selector_class" title="scrapy.contrib.loader.ItemLoader.default_selector_class"><code class="xref py py-attr docutils literal"><span class="pre">default_selector_class</span></code></a>, unless the selector argument is given,
in which case this argument is ignored.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>The item, selector, response and the remaining keyword arguments are
assigned to the Loader context (accessible through the <a class="reference internal" href="#scrapy.contrib.loader.ItemLoader.context" title="scrapy.contrib.loader.ItemLoader.context"><code class="xref py py-attr docutils literal"><span class="pre">context</span></code></a> attribute).</p>
<p><a class="reference internal" href="#scrapy.contrib.loader.ItemLoader" title="scrapy.contrib.loader.ItemLoader"><code class="xref py py-class docutils literal"><span class="pre">ItemLoader</span></code></a> instances have the following methods:</p>
<dl class="method">
<dt id="scrapy.contrib.loader.ItemLoader.get_value">
<code class="descname">get_value</code><span class="sig-paren">(</span><em>value</em>, <em>*processors</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#scrapy.contrib.loader.ItemLoader.get_value" title="永久链接至目标"></a></dt>
<dd><p>Process the given <code class="docutils literal"><span class="pre">value</span></code> by the given <code class="docutils literal"><span class="pre">processors</span></code> and keyword
arguments.</p>
<p>Available keyword arguments:</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"></col>
<col class="field-body"></col>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">参数:</th><td class="field-body"><strong>re</strong> (<em>str</em><em> or </em><em>compiled regex</em>) – a regular expression to use for extracting data from the
given value using <code class="xref py py-meth docutils literal"><span class="pre">extract_regex()</span></code> method,
applied before processors</td>
</tr>
</tbody>
</table>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">scrapy.contrib.loader.processor</span> <span class="k">import</span> <span class="n">TakeFirst</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">loader</span><span class="o">.</span><span class="n">get_value</span><span class="p">(</span><span class="sa">u</span><span class="s1">'name: foo'</span><span class="p">,</span> <span class="n">TakeFirst</span><span class="p">(),</span> <span class="n">unicode</span><span class="o">.</span><span class="n">upper</span><span class="p">,</span> <span class="n">re</span><span class="o">=</span><span class="s1">'name: (.+)'</span><span class="p">)</span>
<span class="go">'FOO`</span>
</pre></div>
</div>
</dd></dl>
<dl class="method">
<dt id="scrapy.contrib.loader.ItemLoader.add_value">
<code class="descname">add_value</code><span class="sig-paren">(</span><em>field_name</em>, <em>value</em>, <em>*processors</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#scrapy.contrib.loader.ItemLoader.add_value" title="永久链接至目标"></a></dt>
<dd><p>Process and then add the given <code class="docutils literal"><span class="pre">value</span></code> for the given field.</p>
<p>The value is first passed through <a class="reference internal" href="#scrapy.contrib.loader.ItemLoader.get_value" title="scrapy.contrib.loader.ItemLoader.get_value"><code class="xref py py-meth docutils literal"><span class="pre">get_value()</span></code></a> by giving the
<code class="docutils literal"><span class="pre">processors</span></code> and <code class="docutils literal"><span class="pre">kwargs</span></code>, and then passed through the
<a class="reference internal" href="#topics-loaders-processors"><span class="std std-ref">field input processor</span></a> and its result
appended to the data collected for that field. If the field already
contains collected data, the new data is added.</p>
<p>The given <code class="docutils literal"><span class="pre">field_name</span></code> can be <code class="docutils literal"><span class="pre">None</span></code>, in which case values for
multiple fields may be added. And the processed value should be a dict
with field_name mapped to values.</p>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">loader</span><span class="o">.</span><span class="n">add_value</span><span class="p">(</span><span class="s1">'name'</span><span class="p">,</span> <span class="sa">u</span><span class="s1">'Color TV'</span><span class="p">)</span>
<span class="n">loader</span><span class="o">.</span><span class="n">add_value</span><span class="p">(</span><span class="s1">'colours'</span><span class="p">,</span> <span class="p">[</span><span class="sa">u</span><span class="s1">'white'</span><span class="p">,</span> <span class="sa">u</span><span class="s1">'blue'</span><span class="p">])</span>
<span class="n">loader</span><span class="o">.</span><span class="n">add_value</span><span class="p">(</span><span class="s1">'length'</span><span class="p">,</span> <span class="sa">u</span><span class="s1">'100'</span><span class="p">)</span>
<span class="n">loader</span><span class="o">.</span><span class="n">add_value</span><span class="p">(</span><span class="s1">'name'</span><span class="p">,</span> <span class="sa">u</span><span class="s1">'name: foo'</span><span class="p">,</span> <span class="n">TakeFirst</span><span class="p">(),</span> <span class="n">re</span><span class="o">=</span><span class="s1">'name: (.+)'</span><span class="p">)</span>
<span class="n">loader</span><span class="o">.</span><span class="n">add_value</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="p">{</span><span class="s1">'name'</span><span class="p">:</span> <span class="sa">u</span><span class="s1">'foo'</span><span class="p">,</span> <span class="s1">'sex'</span><span class="p">:</span> <span class="sa">u</span><span class="s1">'male'</span><span class="p">})</span>
</pre></div>
</div>
</dd></dl>
<dl class="method">
<dt id="scrapy.contrib.loader.ItemLoader.replace_value">
<code class="descname">replace_value</code><span class="sig-paren">(</span><em>field_name</em>, <em>value</em>, <em>*processors</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#scrapy.contrib.loader.ItemLoader.replace_value" title="永久链接至目标"></a></dt>
<dd><p>Similar to <a class="reference internal" href="#scrapy.contrib.loader.ItemLoader.add_value" title="scrapy.contrib.loader.ItemLoader.add_value"><code class="xref py py-meth docutils literal"><span class="pre">add_value()</span></code></a> but replaces the collected data with the
new value instead of adding it.</p>
</dd></dl>
<dl class="method">
<dt id="scrapy.contrib.loader.ItemLoader.get_xpath">
<code class="descname">get_xpath</code><span class="sig-paren">(</span><em>xpath</em>, <em>*processors</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#scrapy.contrib.loader.ItemLoader.get_xpath" title="永久链接至目标"></a></dt>
<dd><p>Similar to <a class="reference internal" href="#scrapy.contrib.loader.ItemLoader.get_value" title="scrapy.contrib.loader.ItemLoader.get_value"><code class="xref py py-meth docutils literal"><span class="pre">ItemLoader.get_value()</span></code></a> but receives an XPath instead of a
value, which is used to extract a list of unicode strings from the
selector associated with this <a class="reference internal" href="#scrapy.contrib.loader.ItemLoader" title="scrapy.contrib.loader.ItemLoader"><code class="xref py py-class docutils literal"><span class="pre">ItemLoader</span></code></a>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"></col>
<col class="field-body"></col>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">参数:</th><td class="field-body"><ul class="first last simple">
<li><strong>xpath</strong> (<em>str</em>) – the XPath to extract data from</li>
<li><strong>re</strong> (<em>str</em><em> or </em><em>compiled regex</em>) – a regular expression to use for extracting data from the
selected XPath region</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="c1"># HTML snippet: &lt;p class="product-name"&gt;Color TV&lt;/p&gt;</span>
<span class="n">loader</span><span class="o">.</span><span class="n">get_xpath</span><span class="p">(</span><span class="s1">'//p[@class="product-name"]'</span><span class="p">)</span>
<span class="c1"># HTML snippet: &lt;p id="price"&gt;the price is $1200&lt;/p&gt;</span>
<span class="n">loader</span><span class="o">.</span><span class="n">get_xpath</span><span class="p">(</span><span class="s1">'//p[@id="price"]'</span><span class="p">,</span> <span class="n">TakeFirst</span><span class="p">(),</span> <span class="n">re</span><span class="o">=</span><span class="s1">'the price is (.*)'</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>
<dl class="method">
<dt id="scrapy.contrib.loader.ItemLoader.add_xpath">
<code class="descname">add_xpath</code><span class="sig-paren">(</span><em>field_name</em>, <em>xpath</em>, <em>*processors</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#scrapy.contrib.loader.ItemLoader.add_xpath" title="永久链接至目标"></a></dt>
<dd><p>Similar to <a class="reference internal" href="#scrapy.contrib.loader.ItemLoader.add_value" title="scrapy.contrib.loader.ItemLoader.add_value"><code class="xref py py-meth docutils literal"><span class="pre">ItemLoader.add_value()</span></code></a> but receives an XPath instead of a
value, which is used to extract a list of unicode strings from the
selector associated with this <a class="reference internal" href="#scrapy.contrib.loader.ItemLoader" title="scrapy.contrib.loader.ItemLoader"><code class="xref py py-class docutils literal"><span class="pre">ItemLoader</span></code></a>.</p>
<p>See <a class="reference internal" href="#scrapy.contrib.loader.ItemLoader.get_xpath" title="scrapy.contrib.loader.ItemLoader.get_xpath"><code class="xref py py-meth docutils literal"><span class="pre">get_xpath()</span></code></a> for <code class="docutils literal"><span class="pre">kwargs</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"></col>
<col class="field-body"></col>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">参数:</th><td class="field-body"><strong>xpath</strong> (<em>str</em>) – the XPath to extract data from</td>
</tr>
</tbody>
</table>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="c1"># HTML snippet: &lt;p class="product-name"&gt;Color TV&lt;/p&gt;</span>
<span class="n">loader</span><span class="o">.</span><span class="n">add_xpath</span><span class="p">(</span><span class="s1">'name'</span><span class="p">,</span> <span class="s1">'//p[@class="product-name"]'</span><span class="p">)</span>
<span class="c1"># HTML snippet: &lt;p id="price"&gt;the price is $1200&lt;/p&gt;</span>
<span class="n">loader</span><span class="o">.</span><span class="n">add_xpath</span><span class="p">(</span><span class="s1">'price'</span><span class="p">,</span> <span class="s1">'//p[@id="price"]'</span><span class="p">,</span> <span class="n">re</span><span class="o">=</span><span class="s1">'the price is (.*)'</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>
<dl class="method">
<dt id="scrapy.contrib.loader.ItemLoader.replace_xpath">
<code class="descname">replace_xpath</code><span class="sig-paren">(</span><em>field_name</em>, <em>xpath</em>, <em>*processors</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#scrapy.contrib.loader.ItemLoader.replace_xpath" title="永久链接至目标"></a></dt>
<dd><p>Similar to <a class="reference internal" href="#scrapy.contrib.loader.ItemLoader.add_xpath" title="scrapy.contrib.loader.ItemLoader.add_xpath"><code class="xref py py-meth docutils literal"><span class="pre">add_xpath()</span></code></a> but replaces collected data instead of
adding it.</p>
</dd></dl>
<dl class="method">
<dt id="scrapy.contrib.loader.ItemLoader.get_css">
<code class="descname">get_css</code><span class="sig-paren">(</span><em>css</em>, <em>*processors</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#scrapy.contrib.loader.ItemLoader.get_css" title="永久链接至目标"></a></dt>
<dd><p>Similar to <a class="reference internal" href="#scrapy.contrib.loader.ItemLoader.get_value" title="scrapy.contrib.loader.ItemLoader.get_value"><code class="xref py py-meth docutils literal"><span class="pre">ItemLoader.get_value()</span></code></a> but receives a CSS selector
instead of a value, which is used to extract a list of unicode strings
from the selector associated with this <a class="reference internal" href="#scrapy.contrib.loader.ItemLoader" title="scrapy.contrib.loader.ItemLoader"><code class="xref py py-class docutils literal"><span class="pre">ItemLoader</span></code></a>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"></col>
<col class="field-body"></col>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">参数:</th><td class="field-body"><ul class="first last simple">
<li><strong>css</strong> (<em>str</em>) – the CSS selector to extract data from</li>
<li><strong>re</strong> (<em>str</em><em> or </em><em>compiled regex</em>) – a regular expression to use for extracting data from the
selected CSS region</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="c1"># HTML snippet: &lt;p class="product-name"&gt;Color TV&lt;/p&gt;</span>
<span class="n">loader</span><span class="o">.</span><span class="n">get_css</span><span class="p">(</span><span class="s1">'p.product-name'</span><span class="p">)</span>
<span class="c1"># HTML snippet: &lt;p id="price"&gt;the price is $1200&lt;/p&gt;</span>
<span class="n">loader</span><span class="o">.</span><span class="n">get_css</span><span class="p">(</span><span class="s1">'p#price'</span><span class="p">,</span> <span class="n">TakeFirst</span><span class="p">(),</span> <span class="n">re</span><span class="o">=</span><span class="s1">'the price is (.*)'</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>
<dl class="method">
<dt id="scrapy.contrib.loader.ItemLoader.add_css">
<code class="descname">add_css</code><span class="sig-paren">(</span><em>field_name</em>, <em>css</em>, <em>*processors</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#scrapy.contrib.loader.ItemLoader.add_css" title="永久链接至目标"></a></dt>
<dd><p>Similar to <a class="reference internal" href="#scrapy.contrib.loader.ItemLoader.add_value" title="scrapy.contrib.loader.ItemLoader.add_value"><code class="xref py py-meth docutils literal"><span class="pre">ItemLoader.add_value()</span></code></a> but receives a CSS selector
instead of a value, which is used to extract a list of unicode strings
from the selector associated with this <a class="reference internal" href="#scrapy.contrib.loader.ItemLoader" title="scrapy.contrib.loader.ItemLoader"><code class="xref py py-class docutils literal"><span class="pre">ItemLoader</span></code></a>.</p>
<p>See <a class="reference internal" href="#scrapy.contrib.loader.ItemLoader.get_css" title="scrapy.contrib.loader.ItemLoader.get_css"><code class="xref py py-meth docutils literal"><span class="pre">get_css()</span></code></a> for <code class="docutils literal"><span class="pre">kwargs</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"></col>
<col class="field-body"></col>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">参数:</th><td class="field-body"><strong>css</strong> (<em>str</em>) – the CSS selector to extract data from</td>
</tr>
</tbody>
</table>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="c1"># HTML snippet: &lt;p class="product-name"&gt;Color TV&lt;/p&gt;</span>
<span class="n">loader</span><span class="o">.</span><span class="n">add_css</span><span class="p">(</span><span class="s1">'name'</span><span class="p">,</span> <span class="s1">'p.product-name'</span><span class="p">)</span>
<span class="c1"># HTML snippet: &lt;p id="price"&gt;the price is $1200&lt;/p&gt;</span>
<span class="n">loader</span><span class="o">.</span><span class="n">add_css</span><span class="p">(</span><span class="s1">'price'</span><span class="p">,</span> <span class="s1">'p#price'</span><span class="p">,</span> <span class="n">re</span><span class="o">=</span><span class="s1">'the price is (.*)'</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>
<dl class="method">
<dt id="scrapy.contrib.loader.ItemLoader.replace_css">
<code class="descname">replace_css</code><span class="sig-paren">(</span><em>field_name</em>, <em>css</em>, <em>*processors</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#scrapy.contrib.loader.ItemLoader.replace_css" title="永久链接至目标"></a></dt>
<dd><p>Similar to <a class="reference internal" href="#scrapy.contrib.loader.ItemLoader.add_css" title="scrapy.contrib.loader.ItemLoader.add_css"><code class="xref py py-meth docutils literal"><span class="pre">add_css()</span></code></a> but replaces collected data instead of
adding it.</p>
</dd></dl>
<dl class="method">
<dt id="scrapy.contrib.loader.ItemLoader.load_item">
<code class="descname">load_item</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#scrapy.contrib.loader.ItemLoader.load_item" title="永久链接至目标"></a></dt>
<dd><p>Populate the item with the data collected so far, and return it. The
data collected is first passed through the <a class="reference internal" href="#topics-loaders-processors"><span class="std std-ref">output processors</span></a> to get the final value to assign to each
item field.</p>
</dd></dl>
<dl class="method">
<dt id="scrapy.contrib.loader.ItemLoader.get_collected_values">
<code class="descname">get_collected_values</code><span class="sig-paren">(</span><em>field_name</em><span class="sig-paren">)</span><a class="headerlink" href="#scrapy.contrib.loader.ItemLoader.get_collected_values" title="永久链接至目标"></a></dt>
<dd><p>Return the collected values for the given field.</p>
</dd></dl>
<dl class="method">
<dt id="scrapy.contrib.loader.ItemLoader.get_output_value">
<code class="descname">get_output_value</code><span class="sig-paren">(</span><em>field_name</em><span class="sig-paren">)</span><a class="headerlink" href="#scrapy.contrib.loader.ItemLoader.get_output_value" title="永久链接至目标"></a></dt>
<dd><p>Return the collected values parsed using the output processor, for the
given field. This method doesn’t populate or modify the item at all.</p>
</dd></dl>
<dl class="method">
<dt id="scrapy.contrib.loader.ItemLoader.get_input_processor">
<code class="descname">get_input_processor</code><span class="sig-paren">(</span><em>field_name</em><span class="sig-paren">)</span><a class="headerlink" href="#scrapy.contrib.loader.ItemLoader.get_input_processor" title="永久链接至目标"></a></dt>
<dd><p>Return the input processor for the given field.</p>
</dd></dl>
<dl class="method">
<dt id="scrapy.contrib.loader.ItemLoader.get_output_processor">
<code class="descname">get_output_processor</code><span class="sig-paren">(</span><em>field_name</em><span class="sig-paren">)</span><a class="headerlink" href="#scrapy.contrib.loader.ItemLoader.get_output_processor" title="永久链接至目标"></a></dt>
<dd><p>Return the output processor for the given field.</p>
</dd></dl>
<p><a class="reference internal" href="#scrapy.contrib.loader.ItemLoader" title="scrapy.contrib.loader.ItemLoader"><code class="xref py py-class docutils literal"><span class="pre">ItemLoader</span></code></a> instances have the following attributes:</p>
<dl class="attribute">
<dt id="scrapy.contrib.loader.ItemLoader.item">
<code class="descname">item</code><a class="headerlink" href="#scrapy.contrib.loader.ItemLoader.item" title="永久链接至目标"></a></dt>
<dd><p>The <a class="reference internal" href="items.html#scrapy.item.Item" title="scrapy.item.Item"><code class="xref py py-class docutils literal"><span class="pre">Item</span></code></a> object being parsed by this Item Loader.</p>
</dd></dl>
<dl class="attribute">
<dt id="scrapy.contrib.loader.ItemLoader.context">
<code class="descname">context</code><a class="headerlink" href="#scrapy.contrib.loader.ItemLoader.context" title="永久链接至目标"></a></dt>
<dd><p>The currently active <a class="reference internal" href="#topics-loaders-context"><span class="std std-ref">Context</span></a> of this
Item Loader.</p>
</dd></dl>
<dl class="attribute">
<dt id="scrapy.contrib.loader.ItemLoader.default_item_class">
<code class="descname">default_item_class</code><a class="headerlink" href="#scrapy.contrib.loader.ItemLoader.default_item_class" title="永久链接至目标"></a></dt>
<dd><p>An Item class (or factory), used to instantiate items when not given in
the constructor.</p>
</dd></dl>
<dl class="attribute">
<dt id="scrapy.contrib.loader.ItemLoader.default_input_processor">
<code class="descname">default_input_processor</code><a class="headerlink" href="#scrapy.contrib.loader.ItemLoader.default_input_processor" title="永久链接至目标"></a></dt>
<dd><p>The default input processor to use for those fields which don’t specify
one.</p>
</dd></dl>
<dl class="attribute">
<dt id="scrapy.contrib.loader.ItemLoader.default_output_processor">
<code class="descname">default_output_processor</code><a class="headerlink" href="#scrapy.contrib.loader.ItemLoader.default_output_processor" title="永久链接至目标"></a></dt>
<dd><p>The default output processor to use for those fields which don’t specify
one.</p>
</dd></dl>
<dl class="attribute">
<dt id="scrapy.contrib.loader.ItemLoader.default_selector_class">
<code class="descname">default_selector_class</code><a class="headerlink" href="#scrapy.contrib.loader.ItemLoader.default_selector_class" title="永久链接至目标"></a></dt>
<dd><p>The class used to construct the <a class="reference internal" href="#scrapy.contrib.loader.ItemLoader.selector" title="scrapy.contrib.loader.ItemLoader.selector"><code class="xref py py-attr docutils literal"><span class="pre">selector</span></code></a> of this
<a class="reference internal" href="#scrapy.contrib.loader.ItemLoader" title="scrapy.contrib.loader.ItemLoader"><code class="xref py py-class docutils literal"><span class="pre">ItemLoader</span></code></a>, if only a response is given in the constructor.
If a selector is given in the constructor this attribute is ignored.
This attribute is sometimes overridden in subclasses.</p>
</dd></dl>
<dl class="attribute">
<dt id="scrapy.contrib.loader.ItemLoader.selector">
<code class="descname">selector</code><a class="headerlink" href="#scrapy.contrib.loader.ItemLoader.selector" title="永久链接至目标"></a></dt>
<dd><p>The <a class="reference internal" href="selectors.html#scrapy.selector.Selector" title="scrapy.selector.Selector"><code class="xref py py-class docutils literal"><span class="pre">Selector</span></code></a> object to extract data from.
It’s either the selector given in the constructor or one created from
the response given in the constructor using the
<a class="reference internal" href="#scrapy.contrib.loader.ItemLoader.default_selector_class" title="scrapy.contrib.loader.ItemLoader.default_selector_class"><code class="xref py py-attr docutils literal"><span class="pre">default_selector_class</span></code></a>. This attribute is meant to be
read-only.</p>
</dd></dl>
</dd></dl>
</div>
<div class="section" id="reusing-and-extending-item-loaders">
<span id="topics-loaders-extending"></span><h2>Reusing and extending Item Loaders<a class="headerlink" href="#reusing-and-extending-item-loaders" title="永久链接至标题"></a></h2>
<p>As your project grows bigger and acquires more and more spiders, maintenance
becomes a fundamental problem, especially when you have to deal with many
different parsing rules for each spider, having a lot of exceptions, but also
wanting to reuse the common processors.</p>
<p>Item Loaders are designed to ease the maintenance burden of parsing rules,
without losing flexibility and, at the same time, providing a convenient
mechanism for extending and overriding them. For this reason Item Loaders
support traditional Python class inheritance for dealing with differences of
specific spiders (or groups of spiders).</p>
<p>Suppose, for example, that some particular site encloses their product names in
three dashes (e.g. <code class="docutils literal"><span class="pre">---Plasma</span> <span class="pre">TV---</span></code>) and you don’t want to end up scraping
those dashes in the final product names.</p>
<p>Here’s how you can remove those dashes by reusing and extending the default
Product Item Loader (<code class="docutils literal"><span class="pre">ProductLoader</span></code>):</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">scrapy.contrib.loader.processor</span> <span class="k">import</span> <span class="n">MapCompose</span>
<span class="kn">from</span> <span class="nn">myproject.ItemLoaders</span> <span class="k">import</span> <span class="n">ProductLoader</span>

<span class="k">def</span> <span class="nf">strip_dashes</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">x</span><span class="o">.</span><span class="n">strip</span><span class="p">(</span><span class="s1">'-'</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">SiteSpecificLoader</span><span class="p">(</span><span class="n">ProductLoader</span><span class="p">):</span>
    <span class="n">name_in</span> <span class="o">=</span> <span class="n">MapCompose</span><span class="p">(</span><span class="n">strip_dashes</span><span class="p">,</span> <span class="n">ProductLoader</span><span class="o">.</span><span class="n">name_in</span><span class="p">)</span>
</pre></div>
</div>
<p>Another case where extending Item Loaders can be very helpful is when you have
multiple source formats, for example XML and HTML. In the XML version you may
want to remove <code class="docutils literal"><span class="pre">CDATA</span></code> occurrences. Here’s an example of how to do it:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">scrapy.contrib.loader.processor</span> <span class="k">import</span> <span class="n">MapCompose</span>
<span class="kn">from</span> <span class="nn">myproject.ItemLoaders</span> <span class="k">import</span> <span class="n">ProductLoader</span>
<span class="kn">from</span> <span class="nn">myproject.utils.xml</span> <span class="k">import</span> <span class="n">remove_cdata</span>

<span class="k">class</span> <span class="nc">XmlProductLoader</span><span class="p">(</span><span class="n">ProductLoader</span><span class="p">):</span>
    <span class="n">name_in</span> <span class="o">=</span> <span class="n">MapCompose</span><span class="p">(</span><span class="n">remove_cdata</span><span class="p">,</span> <span class="n">ProductLoader</span><span class="o">.</span><span class="n">name_in</span><span class="p">)</span>
</pre></div>
</div>
<p>And that’s how you typically extend input processors.</p>
<p>As for output processors, it is more common to declare them in the field metadata,
as they usually depend only on the field and not on each specific site parsing
rule (as input processors do). See also:
<a class="reference internal" href="#topics-loaders-processors-declaring"><span class="std std-ref">Declaring Input and Output Processors</span></a>.</p>
<p>There are many other possible ways to extend, inherit and override your Item
Loaders, and different Item Loaders hierarchies may fit better for different
projects. Scrapy only provides the mechanism; it doesn’t impose any specific
organization of your Loaders collection - that’s up to you and your project’s
needs.</p>
</div>
<div class="section" id="module-scrapy.contrib.loader.processor">
<span id="available-built-in-processors"></span><span id="topics-loaders-available-processors"></span><h2>Available built-in processors<a class="headerlink" href="#module-scrapy.contrib.loader.processor" title="永久链接至标题"></a></h2>
<p>Even though you can use any callable function as input and output processors,
Scrapy provides some commonly used processors, which are described below. Some
of them, like the <a class="reference internal" href="#scrapy.contrib.loader.processor.MapCompose" title="scrapy.contrib.loader.processor.MapCompose"><code class="xref py py-class docutils literal"><span class="pre">MapCompose</span></code></a> (which is typically used as input
processor) compose the output of several functions executed in order, to
produce the final parsed value.</p>
<p>Here is a list of all built-in processors:</p>
<dl class="class">
<dt id="scrapy.contrib.loader.processor.Identity">
<em class="property">class </em><code class="descclassname">scrapy.contrib.loader.processor.</code><code class="descname">Identity</code><a class="headerlink" href="#scrapy.contrib.loader.processor.Identity" title="永久链接至目标"></a></dt>
<dd><p>The simplest processor, which doesn’t do anything. It returns the original
values unchanged. It doesn’t receive any constructor arguments nor accepts
Loader contexts.</p>
<p>Example:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">scrapy.contrib.loader.processor</span> <span class="k">import</span> <span class="n">Identity</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">proc</span> <span class="o">=</span> <span class="n">Identity</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">proc</span><span class="p">([</span><span class="s1">'one'</span><span class="p">,</span> <span class="s1">'two'</span><span class="p">,</span> <span class="s1">'three'</span><span class="p">])</span>
<span class="go">['one', 'two', 'three']</span>
</pre></div>
</div>
</dd></dl>
<dl class="class">
<dt id="scrapy.contrib.loader.processor.TakeFirst">
<em class="property">class </em><code class="descclassname">scrapy.contrib.loader.processor.</code><code class="descname">TakeFirst</code><a class="headerlink" href="#scrapy.contrib.loader.processor.TakeFirst" title="永久链接至目标"></a></dt>
<dd><p>Returns the first non-null/non-empty value from the values received,
so it’s typically used as an output processor to single-valued fields.
It doesn’t receive any constructor arguments, nor accept Loader contexts.</p>
<p>Example:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">scrapy.contrib.loader.processor</span> <span class="k">import</span> <span class="n">TakeFirst</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">proc</span> <span class="o">=</span> <span class="n">TakeFirst</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">proc</span><span class="p">([</span><span class="s1">''</span><span class="p">,</span> <span class="s1">'one'</span><span class="p">,</span> <span class="s1">'two'</span><span class="p">,</span> <span class="s1">'three'</span><span class="p">])</span>
<span class="go">'one'</span>
</pre></div>
</div>
</dd></dl>
<dl class="class">
<dt id="scrapy.contrib.loader.processor.Join">
<em class="property">class </em><code class="descclassname">scrapy.contrib.loader.processor.</code><code class="descname">Join</code><span class="sig-paren">(</span><em>separator=u' '</em><span class="sig-paren">)</span><a class="headerlink" href="#scrapy.contrib.loader.processor.Join" title="永久链接至目标"></a></dt>
<dd><p>Returns the values joined with the separator given in the constructor, which
defaults to <code class="docutils literal"><span class="pre">u'</span> <span class="pre">'</span></code>. It doesn’t accept Loader contexts.</p>
<p>When using the default separator, this processor is equivalent to the
function: <code class="docutils literal"><span class="pre">u'</span> <span class="pre">'.join</span></code></p>
<p>Examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">scrapy.contrib.loader.processor</span> <span class="k">import</span> <span class="n">Join</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">proc</span> <span class="o">=</span> <span class="n">Join</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">proc</span><span class="p">([</span><span class="s1">'one'</span><span class="p">,</span> <span class="s1">'two'</span><span class="p">,</span> <span class="s1">'three'</span><span class="p">])</span>
<span class="go">u'one two three'</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">proc</span> <span class="o">=</span> <span class="n">Join</span><span class="p">(</span><span class="s1">'&lt;br&gt;'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">proc</span><span class="p">([</span><span class="s1">'one'</span><span class="p">,</span> <span class="s1">'two'</span><span class="p">,</span> <span class="s1">'three'</span><span class="p">])</span>
<span class="go">u'one&lt;br&gt;two&lt;br&gt;three'</span>
</pre></div>
</div>
</dd></dl>
<dl class="class">
<dt id="scrapy.contrib.loader.processor.Compose">
<em class="property">class </em><code class="descclassname">scrapy.contrib.loader.processor.</code><code class="descname">Compose</code><span class="sig-paren">(</span><em>*functions</em>, <em>**default_loader_context</em><span class="sig-paren">)</span><a class="headerlink" href="#scrapy.contrib.loader.processor.Compose" title="永久链接至目标"></a></dt>
<dd><p>A processor which is constructed from the composition of the given
functions. This means that each input value of this processor is passed to
the first function, and the result of that function is passed to the second
function, and so on, until the last function returns the output value of
this processor.</p>
<p>By default, stop process on <code class="docutils literal"><span class="pre">None</span></code> value. This behaviour can be changed by
passing keyword argument <code class="docutils literal"><span class="pre">stop_on_none=False</span></code>.</p>
<p>Example:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">scrapy.contrib.loader.processor</span> <span class="k">import</span> <span class="n">Compose</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">proc</span> <span class="o">=</span> <span class="n">Compose</span><span class="p">(</span><span class="k">lambda</span> <span class="n">v</span><span class="p">:</span> <span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">str</span><span class="o">.</span><span class="n">upper</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">proc</span><span class="p">([</span><span class="s1">'hello'</span><span class="p">,</span> <span class="s1">'world'</span><span class="p">])</span>
<span class="go">'HELLO'</span>
</pre></div>
</div>
<p>Each function can optionally receive a <code class="docutils literal"><span class="pre">loader_context</span></code> parameter. For
those which do, this processor will pass the currently active <a class="reference internal" href="#topics-loaders-context"><span class="std std-ref">Loader
context</span></a> through that parameter.</p>
<p>The keyword arguments passed in the constructor are used as the default
Loader context values passed to each function call. However, the final
Loader context values passed to functions are overridden with the currently
active Loader context accessible through the <code class="xref py py-meth docutils literal"><span class="pre">ItemLoader.context()</span></code>
attribute.</p>
</dd></dl>
<dl class="class">
<dt id="scrapy.contrib.loader.processor.MapCompose">
<em class="property">class </em><code class="descclassname">scrapy.contrib.loader.processor.</code><code class="descname">MapCompose</code><span class="sig-paren">(</span><em>*functions</em>, <em>**default_loader_context</em><span class="sig-paren">)</span><a class="headerlink" href="#scrapy.contrib.loader.processor.MapCompose" title="永久链接至目标"></a></dt>
<dd><p>A processor which is constructed from the composition of the given
functions, similar to the <a class="reference internal" href="#scrapy.contrib.loader.processor.Compose" title="scrapy.contrib.loader.processor.Compose"><code class="xref py py-class docutils literal"><span class="pre">Compose</span></code></a> processor. The difference with
this processor is the way internal results are passed among functions,
which is as follows:</p>
<p>The input value of this processor is <em>iterated</em> and the first function is
applied to each element. The results of these function calls (one for each element)
are concatenated to construct a new iterable, which is then used to apply the
second function, and so on, until the last function is applied to each
value of the list of values collected so far. The output values of the last
function are concatenated together to produce the output of this processor.</p>
<p>Each particular function can return a value or a list of values, which is
flattened with the list of values returned by the same function applied to
the other input values. The functions can also return <code class="docutils literal"><span class="pre">None</span></code> in which
case the output of that function is ignored for further processing over the
chain.</p>
<p>This processor provides a convenient way to compose functions that only
work with single values (instead of iterables). For this reason the
<a class="reference internal" href="#scrapy.contrib.loader.processor.MapCompose" title="scrapy.contrib.loader.processor.MapCompose"><code class="xref py py-class docutils literal"><span class="pre">MapCompose</span></code></a> processor is typically used as input processor, since
data is often extracted using the
<a class="reference internal" href="selectors.html#scrapy.selector.Selector.extract" title="scrapy.selector.Selector.extract"><code class="xref py py-meth docutils literal"><span class="pre">extract()</span></code></a> method of <a class="reference internal" href="selectors.html#topics-selectors"><span class="std std-ref">selectors</span></a>, which returns a list of unicode strings.</p>
<p>The example below should clarify how it works:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">filter_world</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="kc">None</span> <span class="k">if</span> <span class="n">x</span> <span class="o">==</span> <span class="s1">'world'</span> <span class="k">else</span> <span class="n">x</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">scrapy.contrib.loader.processor</span> <span class="k">import</span> <span class="n">MapCompose</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">proc</span> <span class="o">=</span> <span class="n">MapCompose</span><span class="p">(</span><span class="n">filter_world</span><span class="p">,</span> <span class="n">unicode</span><span class="o">.</span><span class="n">upper</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">proc</span><span class="p">([</span><span class="sa">u</span><span class="s1">'hello'</span><span class="p">,</span> <span class="sa">u</span><span class="s1">'world'</span><span class="p">,</span> <span class="sa">u</span><span class="s1">'this'</span><span class="p">,</span> <span class="sa">u</span><span class="s1">'is'</span><span class="p">,</span> <span class="sa">u</span><span class="s1">'scrapy'</span><span class="p">])</span>
<span class="go">[u'HELLO, u'THIS', u'IS', u'SCRAPY']</span>
</pre></div>
</div>
<p>As with the Compose processor, functions can receive Loader contexts, and
constructor keyword arguments are used as default context values. See
<a class="reference internal" href="#scrapy.contrib.loader.processor.Compose" title="scrapy.contrib.loader.processor.Compose"><code class="xref py py-class docutils literal"><span class="pre">Compose</span></code></a> processor for more info.</p>
</dd></dl>
</div>
</div>
<h2>
            讨论
            <a class="headerlink" href="#discuss" title="永久链接至标题"></a>
</h2>
<div id="disqus_thread"></div>
</div>
<div class="articleComments">
</div>
</div>
    
</body></html>
